@name VR Holo Designer v1.6.0

#[
    Note for Fasteroid/expression2-public Github browsers: 
    
    This chip won't work without its #includes.
    Check the README in the repo for more details!
]#

# GLOBAL CONSTANTS
@persist NULL:table
@persist PLY:entity 
@persist MENU_DATA:table SPAWNMENU_W SPAWNMENU_H SPAWNMENU_SCL MENU_BASE SELECT_BASE SPAWNMENU_SPACING X Y MENU_SPAWNED MENU_ENT:entity HOLO_MODELS:array HOLO_MODEL_OFFSETS:table DEFAULT_SCALE:vector DEFAULT_SIZE
@persist HANDLE_DATA:table HANDLE_OPPOSITES:table HANDLE_CENTER HANDLE_SCL HANDLE_COLOR:vector SLIDER_HOVER_DISTANCE
@persist SHREDDER_BASE SHREDDER_TOP SHREDDER_BOTTOM SHREDDER:entity
@persist BUCKET_BASE BUCKET_PAINT BUCKET_ENT:entity BUCKET_PAINT_ENT:entity BUCKET_SPAWNED BUCKET_SATS BUCKET_BRIGHTS BUCKET_LEN BUCKET_ANGLE HUE_CURRENT HSV_CURRENT:vector BUCKET_POINTER BUCKET_DATA:table BUCKET_POINTER_ENT:entity
@persist ORIGIN ORIGIN_ENT:entity
@persist POS_SNAP_DIVISORS:array ANG_SNAP_DIVISORS:array SCL_SNAP_DIVISORS:array
@persist SLIDER_DATA:table SLIDER_NOTCHES_DONE SLIDER_SIZE SLIDER_BORDER

# GLOBAL PERSISTS
@persist Grab_Holos:table Grab_Holo_AvailableIDs:array Grab_Holo_MaxID
@persist Shredding_Holos:table Shredder_Speed Shredder_Rotation Shredder_Flasher
@persist Bucket_Flip Bucket_State
@persist Highlight_Current:array Highlight_OldColor:array Highlight_OldAlpha:array
@persist Hand_Local_Ang:angle Hand_Local_Pos:vector
@persist Handle_Axis:vector Opposite_Handle:table Handle_Parent:table
@persist New_Holo_Group:string

# ACTIONS & STATES
@persist Target_Use:table   Target_M1:table  Target_M2:table
@persist Action_Use         Action_M1        State_M2
@persist Action_Holding

# ACTION & STATE ENUMS
@persist USE_GrabbableHolo                                         USE_MenuHolo               USE_Origin
@persist                     M1_BucketPointer    M1_ScaleHandle                  M1_Slider
@persist HOLD_GrabbableHolo  HOLD_BucketPointer  HOLD_ScaleHandle                HOLD_Slider  HOLD_Origin
@persist M2_SelectLock M1_Duplicate

#include "betterhololib"
#include "holostructurelib"

# you can now create your previously created structures!
# use .c <struct> to create them at the origin.
# #include "wrecking_ball/models/leg2"

if( first() ){
    
    # -------- GLOBAL_CONSTANTS -------- #
    
        PLY = owner()
        
        SPAWNMENU_W = 6
        SPAWNMENU_SCL = 14
        SPAWNMENU_SPACING = 2
        
        HANDLE_SCL = 4
        HANDLE_COLOR = vec(100)
        
        BUCKET_SATS = 6
        BUCKET_BRIGHTS = 6
        BUCKET_ANGLE = 40

        # snap divisors; bigger = more precise; must be real integers
        # must be in ascending order to work correctly
        # TODO: automatic sorting that won't tick quota the chip
        POS_SNAP_DIVISORS = array(1,2,4,8,16)
        ANG_SNAP_DIVISORS = array(1,2,3,4,5,6,8,12,15)
        SCL_SNAP_DIVISORS = array(1,2,4,8)
        
        HOLO_MODELS = array(
            "rcylinder_thick",
            "rcylinder",
            "rcylinder_thin",
            "rcube_thick",
            "rcube",
            "rcube_thin",
            "hq_rcylinder_thick",
            "hq_rcylinder",
            "hq_rcylinder_thin",
            "hq_rcube_thick",
            "hq_rcube",
            "hq_rcube_thin",
            "hq_tube_thick",
            "hq_tube",
            "hq_tube_thin",
            "cube",
            "cplane",
            "plane",
            "torus3",
            "torus2",
            "torus",
            "icosphere3",
            "icosphere2",
            "icosphere",
            "right_prism",
            "prism",
            "hq_cone",
            "tetra",
            "pyramid",
            "cone",
            "hq_torus_thick",
            "hq_torus_oldsize",
            "hq_torus",
            "hq_cylinder",
            "hq_icosphere",
            "hq_dome"
        )
        
        HOLO_MODEL_OFFSETS = table(
            "right_prism" = ang(-90,0,90),
            "prism" = ang(0,90,0),
            "plane" = ang(-45,0,0),
            "cplane" = ang(-45,0,0)
        )
        
    # -------- Global_transients_ -------- #
    
        # global values defined every tick that should not persist
        # declared up here (w/ dummy values) so the functions below can use them
        Hand_pos_  = vec()
        Hand_ang_  = ang()
        GridPos_x_ = 0
        GridPos_y_ = 0
        GridPos_z_ = 0
        
    # -------- variable initialization -------- #
    
        # don't actually call this; these start as @persist defaults
        function supressInitializationWarnings(){
            BUCKET_ENT = noentity() HANDLE_CENTER = 0 BUCKET_POINTER = 0 BUCKET_LEN = 0 HUE_CURRENT = 0 BUCKET_PAINT = 0 SHREDDER_BASE = 0 MENU_SPAWNED = 0 BUCKET_SPAWNED = 0 NULL = table() BUCKET_DATA = table() HANDLE_DATA = table() MENU_DATA = table() HANDLE_OPPOSITES = table() DEFAULT_SCALE = vec(0.9)*SPAWNMENU_SCL-SPAWNMENU_SPACING Grab_Holos = table() Shredding_Holos = table() Opposite_Handle = NULL Grab_Holo_AvailableIDs = array() Highlight_Current = array() Highlight_OldColor = array() Highlight_OldAlpha = array() Bucket_Flip = 0 Grab_Holo_MaxID = 0 Action_Holding = 0 Shredder_Flasher = 0 Shredder_Speed= 0 Shredder_Rotation = 0 Hand_Local_Pos = vec() Hand_Local_Ang = ang() SLIDER_NOTCHES_DONE = 0 MENU_BASE = 0 SLIDER_DATA = table() Target_Use = table() M2_SelectLock = 0 BUCKET_POINTER_ENT = noentity() ORIGIN_ENT = noentity() ORIGIN = 0 New_Holo_Group = "" BUCKET_PAINT_ENT = noentity()
        }
        
        # cached values; don't touch these
        DEFAULT_SCALE  = vec(0.9)*SPAWNMENU_SCL-SPAWNMENU_SPACING
        DEFAULT_SIZE = DEFAULT_SCALE[1]
        
        SLIDER_SIZE = HANDLE_SCL*0.5
        SLIDER_BORDER = SLIDER_SIZE + SPAWNMENU_SPACING
        SLIDER_HOVER_DISTANCE = 0.75
        
        for(I=1, BUCKET_SATS){
            BUCKET_DATA[I,table] = table()
        }

    # -------- functions -------- #
    
        # Feel free to modify this to your liking.
        # I'm from the US, so I use M/D/Y
        function string getTimeStamp(){
            local MONTHS = array("january","february","march","april","may","june","july","august","september","october","november","december")
            local D = date()
            return MONTHS[ D["month",number], string ] + " " + D["day",number] + " " + D["year",number]
        }
        
        function number array:binarySearchClosest(Target:number){
            local L = 1
            local R = This:count()
            while( L+1 < R ){
                local C = floor( (L+R)/2 )
                if(This[C,number] < Target){
                    L = C
                }
                else {
                    R = C
                }
            }
            if( abs(This[L,number] - Target) < abs(This[R,number] - Target) ){
                return This[L,number]
            }
            else{
                return This[R,number]
            }
        }
        
        # algorithm stolen from PA, no guarantees it'll work on everything
        function table entity:getMirrored(Origin:vector, Axis:vector){
            local Pos = This:pos()
            Pos = Pos - Origin
            Pos = Pos - 2 * Axis:dot(Pos) * Axis
            Pos = Pos + Origin
            
            local Angle = This:toWorld(ang(180,0,0))
            Angle = Angle:rotateAroundAxis(Axis,180)
            
            return table( "pos" = Pos, "ang" = Angle )
        }

        function setHoloLock(){
            if(!Target_Use["trueid",number]){ return }
            State_M2 = M2_SelectLock
            Target_M2 = Target_Use
            holoEntity(HANDLE_CENTER):soundPlay("lock",1,"buttons/button14.wav")
            holoColor(HANDLE_CENTER, vec(255,0,0))
        }
        function clearHoloLock(){
            State_M2 = 0
            Target_M2 = NULL
            holoColor(HANDLE_CENTER, vec(255))
            holoEntity(HANDLE_CENTER):soundPlay("unlock",1,"buttons/button15.wav")
        }
        
        function updateHandles(Scale:vector){
            
            for(I=1,HANDLE_DATA:count()){
                local H = HANDLE_DATA[I,table]
                
                # fixes some stupid hologram bug, don't ask why
                holoUnparent(H["trueid",number])
                holoParent(H["trueid",number],HANDLE_CENTER)
            
                holoPos( H["trueid",number], holoEntity(HANDLE_CENTER):toWorld(H["slider",vector]*Scale*0.5) )
            }
            holoScaleUnits(HANDLE_CENTER,Scale)
        }
    
        function setHandleAlphas(A:number){
            local Keys = HANDLE_DATA:keys()
            foreach(_:number,ID:string=Keys){
                local H = HANDLE_DATA[ID,table]
                holoAlpha( H["trueid",number], A )
            }
        }
        
        function table:attachHandles(){
            Handle_Parent = This
            holoAng(HANDLE_CENTER,Handle_Parent["ent",entity]:angles())
            holoPos(HANDLE_CENTER,Handle_Parent["ent",entity]:pos())
            holoParent(HANDLE_CENTER,This["trueid",number])
            holoModel(HANDLE_CENTER,This["model",string])
            holoScale(HANDLE_CENTER,holoScale(This["trueid",number]))
        }
        
        function number nextGrabbableID(){
            if( Grab_Holo_AvailableIDs:count() == 0 ){
                Grab_Holo_MaxID++
                return Grab_Holo_MaxID
            }
            else {
                return Grab_Holo_AvailableIDs:popNumber()
            } 
        }
    
        function table holoCreateGrabbable(Options:table){
            local H = holoAlloc()
            
            holoModel(H,Options["model",string])
            holoAng(H,Options["ent",entity]:angles())
            holoPos(H,Options["ent",entity]:pos())
            holoMaterial(H,Options["ent",entity]:getMaterial())
            holoScaleUnits(H,Options["scale",vector])
            holoColor(H,Options["ent",entity]:getColor())
            
            local GID = nextGrabbableID()
            
            local Holo = table(
                "ent" = holoEntity(H),
                "trueid"  = H,
                "grabid" = GID,
                "scale" = Options["scale",vector],
                "model" = Options["model",string],
                "group" = New_Holo_Group
            )
            Grab_Holos[GID,table] = Holo
            
            return Holo
        }
        
        function convertToGrabbable(H:number,_:number){
            local GID = nextGrabbableID()
            local Holo = table(
                "ent" = holoEntity(H),
                "trueid"  = H,
                "grabid" = GID,
                "scale" = holoScaleUnits(H),
                "model" = holoEntity(H):model(),
                "group" = New_Holo_Group
            )
            Grab_Holos[GID,table] = Holo
        }
        
        function holoFreeGrabbable(BaseHolo:table){
            holoUnparent(HANDLE_CENTER)

            BaseHolo["trueid",number]:holoFree()
            
            # for now I'm just clearing the table and will check for that when I export
            # actually removing them won't be constant time and is therefore stupid
            Grab_Holo_AvailableIDs:pushNumber(BaseHolo["grabid",number])
            BaseHolo:clear()

        }
        
        function holoShredGrabbable(BaseHolo:table){
            holoUnparent(HANDLE_CENTER)
            holoPos(HANDLE_CENTER,entity():pos() - vec(0,0,200))
            
            local DeleteAnimation = BaseHolo:clone()
    
            DeleteAnimation["deathpos",vector] = DeleteAnimation["ent",entity]:pos()
            DeleteAnimation["deathscale",vector] = DeleteAnimation["scale",vector]
            DeleteAnimation["hp",number] = 1
            
            if( (State_M2 == M2_SelectLock) & (Target_M2 == BaseHolo) ){
                clearHoloLock()
            }
            BaseHolo:clear() # can't free the entity yet since it's needed for animation
            
            Shredding_Holos:pushTable(DeleteAnimation)
        }
        
        function number table:containsPoint(V:vector){
            local Test = This["ent",entity]:toLocal(V)
            local Scale = This["scale",vector] * 0.5
            return inrange(Test,-Scale,Scale)
        }
        
        # replaces old and bug-prone highlighting system
        function number number:highlight(Color:vector,Alpha:number,Group:number){
            if( This != Highlight_Current[Group,number] ){
                holoColor(Highlight_Current[Group,number], Highlight_OldColor[Group,vector], Highlight_OldAlpha[Group,number])
                
                Highlight_Current[Group,number] = This
                Highlight_OldColor[Group,vector] = holoEntity(This):getColor()
                Highlight_OldAlpha[Group,number] = holoEntity(This):getAlpha()
                
                holoColor(This, Color, Alpha)
                return 1
            }
            else{
                holoColor(This, Color, Alpha)
            }
            return 0
        }
        
        function number table:exists(Y:number,X:number){
            return This:exists(Y) & This[Y,table]:exists(X)
        }

        function generateSlider(Name:string, Center:vector, Values:array){
            
            local MaxPos = 0.9*SPAWNMENU_SCL - SLIDER_BORDER/2
            
            local SLIDER_BASE = holoAlloc()
            holoPos(SLIDER_BASE, entity():toWorld(Center))
            holoScaleUnits(SLIDER_BASE, vec(0.01,1.8*SPAWNMENU_SCL,SLIDER_BORDER))
            holoColor(SLIDER_BASE,vec(10,11,12),100)
            holoParent(SLIDER_BASE,MENU_BASE)
            
            local SLIDER_ACCENT = holoAlloc()
            holoPos(SLIDER_ACCENT, entity():toWorld(Center+vec(0.25,0,0)))
            holoScaleUnits(SLIDER_ACCENT, vec(0.01,1.8*SPAWNMENU_SCL - SLIDER_SIZE,SLIDER_SIZE/2))
            holoColor(SLIDER_ACCENT,vec(40),150)
            holoParent(SLIDER_ACCENT,SLIDER_BASE)
            
            local SLIDER = holoAlloc()
            holoPos(SLIDER, entity():toWorld(Center+vec(SLIDER_HOVER_DISTANCE,MaxPos,0)))
            holoScaleUnits(SLIDER, vec(0.5,SLIDER_SIZE,SLIDER_SIZE))
            holoParent(SLIDER,SLIDER_BASE)
            
            local Temp = holoEntity(SLIDER)
            Temp["slider_context",string] = Name # so we can find our data later
            
            local Max = Values:max()
            local Min = Values:min()
            
            SLIDER_DATA[Name,table] = table(
                "name" = Name,
                "values" = Values,
                "anim_value" = Max,
                "value"  = Max,
                "max"    = Max,
                "min"    = Min,
                "range"  = Max-Min,
                "maxpos" = MaxPos,
                "notches" = 0,
                # ---------------------
                "slider_base" = SLIDER_BASE,
                "slider" = SLIDER,
                "slider_accent" = SLIDER_ACCENT,
                "slider_ent" = holoEntity(SLIDER),
                "slider_base_ent" = holoEntity(SLIDER_BASE)
            )
        }
        
        function number table:sliderToWorld(Value:number){
            Value = (Value - This["min",number]) / This["range",number] # 0-1
            return  (Value - 0.5)*2*This["maxpos",number]               # local space
        }
        
        function number table:worldToSlider(Pos:number){
            Pos = clamp( (Pos/This["maxpos",number])*0.5 + 0.5, 0, 1) # 0-1
            return This["min",number] + Pos*This["range",number]       # min-max
        }
        
    # -------- ACTION_Enums -------- #
        
        USE_GrabbableHolo = 1
        USE_MenuHolo      = 4
        USE_Origin        = 6
        
        M1_ScaleHandle    = 2
        M1_BucketPointer  = 3
        M1_Slider         = 5
        M1_Duplicate      = 1
        
        HOLD_GrabbableHolo = 1
        HOLD_ScaleHandle   = 2
        HOLD_BucketPointer = 3
        HOLD_Slider        = 5
        HOLD_Origin        = 6
        
        M2_SelectLock      = 1

    # -------- Actions -------- #
    
        function action_holdingNothing(){
            
            # these have to be reset when constantly if nothing is held
            Action_Use = 0
            Action_M1  = 0
            Target_M1  = NULL
            Target_Use = NULL
                
            # ---- handle highlighting the template holograms on the spawnmenu
                if( GridPos_z_==0 ){
                    
                    local Hovered = MENU_DATA[GridPos_y_, table][GridPos_x_, table]
                    local HLChange = Hovered["trueid",number]:highlight( vec(255), 255, 0 )
                    
                    if( Hovered["trueid",number] ){
                        
                        if( HLChange ){
                            
                            0:highlight(vec(),0,2) # clear any scale handle highlighting
                            holoAlpha(HANDLE_CENTER,255)
                            holoEntity(Hovered["trueid",number]):soundPlay("hover"+Hovered["trueid",number],0.2,"common/talk.wav")
                            Hovered:attachHandles()
                            updateHandles(DEFAULT_SCALE)
                            
                        }
                        
                          #print("set USE_MenuHolo")
                          Action_Use = USE_MenuHolo
                          Target_Use = Hovered
                        return
                        
                    }
                    
                }
                else{
                    0:highlight(vec(),0,0) # clear any scale handle highlighting    
                }
            # ----
            
            # ---- handle misc UI elements
            
                foreach(_:string, T:table = SLIDER_DATA){
                    if( T["slider_ent",entity]:pos():distance2(Hand_pos_) < (HANDLE_SCL/2)^2 ){
                        
                          Action_Use = 0
                          Action_M1  = M1_Slider
                          Target_M1  = T
                        
                        T["slider_accent",number]:highlight(vec(255), 150, 3)
                                                return
                    }
                }
                # if we got here, nothing should be highlighted
                0:highlight(vec(), 255, 3)
                
                if(BUCKET_POINTER_ENT:pos():distance(Hand_pos_) < BUCKET_LEN*1.25){
                    
                      Action_Use = 0
                      Action_M1  = M1_BucketPointer
                                          
                    BUCKET_POINTER:highlight(hsv2rgb(HUE_CURRENT,1,1), 255, 1)
                                        return
                    
                }
                0:highlight(vec(),0,1)
                
            # ----
            
            
            # ---- handle highlighting scale pointers and picking nearest holo
                
                # first find nearest grabbable holo

                if( State_M2 != M2_SelectLock ){
                    local NearestHoloDist = inf()
                    local IsOrigin = 0
                    
                    local OriginDist = ORIGIN_ENT:pos():distance(Hand_pos_)
                    if( OriginDist < 5 ){
                        IsOrigin = 1
                        NearestHoloDist = OriginDist
                    }
                    
                    for(I=1,Grab_Holos:count()){
                        local Holo = Grab_Holos[I,table]
                        local TestDist = Holo["ent",entity]:pos():distance2(Hand_pos_)
                        if(TestDist<NearestHoloDist){
                            NearestHoloDist = TestDist
                            Target_Use = Holo
                            IsOrigin = 0
                        }
                    }
                
                    if( Target_Use["trueid",number] & Target_Use:containsPoint(Hand_pos_) ){ 
                        holoAlpha(HANDLE_CENTER,255)
                        Action_Use = USE_GrabbableHolo
                    }
                    else{
                        holoAlpha(HANDLE_CENTER,0)

                            if( IsOrigin ){
                                Action_Use = USE_Origin
                                ORIGIN:highlight(vec(255),255,3)
                                return
                            }
                            else {
                                0:highlight(vec(),0,3)
                            }
                            
                        if( NearestHoloDist > Target_Use["scale",vector]:length2() ){ # are we even sort of near it?
                            0:highlight(vec(),0,2) # clear any scale handle highlighting
                            return
                        }
                    }
                }
                else {
                    Target_Use = Target_M2
                    Action_Use = USE_GrabbableHolo
                }
                
                
                # now nearest scale handle
                local NearestHandleDist = 2*HANDLE_SCL^2 # nothing further allowed
                for(I=1,HANDLE_DATA:count()){
                    local Holo = HANDLE_DATA[I,table]
                    local TestDist = Holo["ent",entity]:pos():distance2(Hand_pos_)
                    if(TestDist<NearestHandleDist){
                        NearestHandleDist = TestDist
                        Target_M1 = Holo
                        Action_M1 = M1_ScaleHandle
                        #print("set M1_ScaleHandle")
                    }
                }
               
                # attach handles if applicable 
                if( Target_Use["trueid",number] & Handle_Parent!=Target_Use ){
                    Target_Use["ent",entity]:soundPlay("hover"+Target_Use["trueid",number],0.2,"common/talk.wav")
                    Target_Use:attachHandles()
                    updateHandles(Target_Use["scale",vector])
                }
                
                # highlight closest scale handle if applicable
                if( changed(Target_M1["trueid",number]) ){
                    Target_M1["trueid",number]:highlight(vec(0,255,0), 150, 2)
                }
            
                
                return
            # ----
            
        } 
        # ------------
        
        
        function action_holdingScaleHandle(){
            
            local O = Opposite_Handle["ent",entity]
            local Snap  = SLIDER_DATA["scl",table]["value",number]
            local HandOnAxis = O:toLocal( Hand_pos_+Hand_Local_Pos )*positive(Target_M1["slider",vector])
            HandOnAxis = round(HandOnAxis / DEFAULT_SIZE * Snap ) * DEFAULT_SIZE / Snap
            local HandOnWorldAxis = O:toWorld(HandOnAxis)
            local Center = (HandOnWorldAxis+Opposite_Handle["ent",entity]:pos())*0.5
            local Scale = Target_Use["scale",vector]*(1-positive(Target_M1["slider",vector])) + HandOnAxis*Target_M1["slider",vector]
        
            holoPos(Target_Use["trueid",number], Center)
            holoScaleUnits(Target_Use["trueid",number],Scale)
            holoPos(Target_M1["trueid",number], HandOnWorldAxis )
            Target_Use["scale",vector] = Scale
            holoPos(HANDLE_CENTER,Center)
            updateHandles(Target_Use["scale",vector])
            
        }
        # ------------
        
        
        function action_holdingBucketPointer(){
    
            local BucketPos = BUCKET_ENT:toLocal(Hand_pos_)
            
            local BucketScaler1 = (BUCKET_ANGLE/(BUCKET_SATS-1))*2
            local BucketScaler2 = (SPAWNMENU_SCL*1.6/BUCKET_BRIGHTS)       
            local Odd1 = (BUCKET_SATS%2)
            local Odd2 = (BUCKET_BRIGHTS%2)        
            
            local BucketYaw = ceil(angnorm(BucketPos:setZ(0):toAngle())[2]/BucketScaler1-0.5*Odd1)
            local BucketZ = ceil(BucketPos[3]/BucketScaler2-0.5*Odd2)-1
            local BucketYawOffset = ceil(BUCKET_SATS/2)+1
                  BucketYaw = BucketYaw-BucketYawOffset
            local BucketZOffset = ceil(BUCKET_BRIGHTS/2)
                  BucketZ = BucketZ-BucketZOffset
                  BucketYaw = clamp(BucketYaw,-BUCKET_SATS-Odd1,-1-Odd1)
                  BucketZ = clamp(BucketZ,-BUCKET_BRIGHTS-Odd2,-1-Odd2)+Odd2
            
            local Rotation = ang(0,(BucketYaw+BucketYawOffset-0.5*!Odd1)*BucketScaler1,0)
            
            holoPos(BUCKET_POINTER,BUCKET_ENT:toWorld( (Rotation:forward()*(SPAWNMENU_SCL+BUCKET_LEN)):setZ( (BucketZ+BucketZOffset+0.5*!Odd2)*BucketScaler2 ) ))
            holoAng(BUCKET_POINTER,BUCKET_ENT:toWorld( Rotation:setPitch(-90) ))
            
                  BucketYaw = BUCKET_SATS+BucketYaw+Odd1+1
                  BucketZ   = BUCKET_BRIGHTS+BucketZ+1
            local ColorData = BUCKET_DATA[BucketYaw,table][BucketZ,table]
            
            if(changed(ColorData["trueid",number])){
                local SoundN = randint(1,4)
                BUCKET_ENT:soundPlay("splat"+SoundN,0.2,"player/footsteps/gravel"+SoundN+".wav")
                soundPitch("splat"+SoundN,255)
            }
    
            if(Bucket_Flip==BUCKET_BRIGHTS){
                HUE_CURRENT = ColorData["hue",number]
                holoColor(BUCKET_POINTER,hsv2rgb(HUE_CURRENT,1,1))
            }
            elseif(Bucket_Flip==0){
                HSV_CURRENT = ColorData["hsv",vector]
            }
            holoColor(BUCKET_PAINT,hsv2rgb(HSV_CURRENT:setX(HUE_CURRENT)))        
            
        } 
        # ------------
        
        
        function action_holdingGrabbableHolo(){
            
            # ---- color via paint bucket
            
                local PaintTest = BUCKET_ENT:toLocal(Target_Use["ent",entity]:pos())
                if( PaintTest:setZ(0):length()<=0.9*SPAWNMENU_SCL & abs(PaintTest[3])<SPAWNMENU_SCL*0.9 ){
                    local BucketVictim = Target_Use["ent",entity]
                    local NewColor = BUCKET_PAINT_ENT:getColor()
                    local NewMater = BUCKET_PAINT_ENT:getMaterial()
                    if( BucketVictim:getColor() != NewColor | BucketVictim:getMaterial() != NewMater ){
                        holoColor(Target_Use["trueid",number],NewColor)
                        holoMaterial(Target_Use["trueid",number],NewMater)
                        BUCKET_ENT:soundPlay("dunk",0.2,"player/footsteps/mud2.wav")
                    }
                }
                
            # ----
            
            # ---- shredder
                if( inrange(holoEntity(SHREDDER_BASE):toLocal(Target_Use["ent",entity]:pos()),-vec(0.75)*SPAWNMENU_SCL,vec(0.75,0.75,1.5)*SPAWNMENU_SCL) ){
                    Shredder_flash_ = 1 
                    Shredder_spin_  = 1
                }
                elseif( inrange(holoEntity(SHREDDER_BASE):toLocal(Target_Use["ent",entity]:pos() + $Hand_pos_),-vec(0.75)*SPAWNMENU_SCL,vec(0.75,0.75,1.5)*SPAWNMENU_SCL) ){
                    Shredder_flash_ = 2
                    Shredder_spin_  = 1
                }
                elseif( inrange(holoEntity(SHREDDER_BASE):toLocal(Target_Use["ent",entity]:pos()),-vec(0.75)*SPAWNMENU_SCL,vec(0.9,0.9,3)*SPAWNMENU_SCL) ){
                    Shredder_spin_ = 1
                }
            # ----
            
            # move the holo
            
            local Snap_Pos = SLIDER_DATA["pos",table]["value",number]
            local Snap_Ang = SLIDER_DATA["ang",table]["value",number]
            
            Worlds = toWorldPosAng(Hand_Local_Pos,Hand_Local_Ang,Hand_pos_,Hand_ang_)
            holoPos(Target_Use["trueid",number],round(Worlds[1,vector] * Snap_Pos / DEFAULT_SIZE) * DEFAULT_SIZE / Snap_Pos)
            holoAng(Target_Use["trueid",number],round(Worlds[2,angle] * Snap_Ang / 90 ) * 90 / Snap_Ang)
            
        }
        # ------------
        

        function action_holdingSlider(){
            
            local P = Target_M1["slider_base_ent",entity]:toLocal( Hand_pos_ ):y()
            P = Target_M1:worldToSlider(P)
            
            local Nearest = Target_M1["values",array]:binarySearchClosest(P)
            
            Target_M1["value",number] = Nearest
            Target_M1["anim_value",number] = Target_M1["anim_value",number]*0.99 + P*0.01
            
        }
        # ------------
        

        function action_holdingOrigin(){
            
            local Snap_Pos = SLIDER_DATA["pos",table]["value",number]
            local Snap_Ang = SLIDER_DATA["ang",table]["value",number]
            
            Worlds = toWorldPosAng(Hand_Local_Pos,Hand_Local_Ang,Hand_pos_,Hand_ang_)
            holoPos(ORIGIN,round(Worlds[1,vector] * Snap_Pos / DEFAULT_SIZE) * DEFAULT_SIZE / Snap_Pos)
            holoAng(ORIGIN,round(Worlds[2,angle] * Snap_Ang / 90 ) * 90 / Snap_Ang)
            
        }
        # ------------
        
    # -------- scaling handle population -------- #
    
        Sliders = array()
        for(X=-1,1){ # I'm lazy
            for(Y=-1,1){
                for(Z=-1,1){
                    if( !(X==0 & Y==0 & Z==0) ){
                        Sliders:pushVector( vec(X,Y,Z) )
                    }
                }
            }
        }
        
        HANDLE_CENTER = holoAlloc()
        holoMaterial(HANDLE_CENTER,"models/wireframe")
        # first, make all the draggable handles
      
        for(I=1,Sliders:count()){
            local Handle_Axis = Sliders[I,vector]
            local H = holoAlloc(entity():toWorld(Handle_Axis*DEFAULT_SCALE*0.5))
            holoModel(H,"hq_icosphere")
            holoColor(H,HANDLE_COLOR,100)
            holoScaleUnits(H,vec(HANDLE_SCL*0.5))
            holoParent(H,HANDLE_CENTER)
            holoMaterial(H,"lights/white")
            local Holo = table(
                "trueid" = H,
                "slider" = Handle_Axis,
                "ishandle" = 1,
                "ent" = holoEntity(H)
            )
            HANDLE_DATA[I,table] = Holo
            Opp = round(-Handle_Axis)
            HANDLE_OPPOSITES[ Opp+"", table ] = Holo
        }
    
    # -------- important holograms -------- #

        MENU_BASE = holoAlloc()
        holoParent(MENU_BASE,entity())
        holoColor(MENU_BASE,vec(10,11,12),100)
    
        SPAWNMENU_H = ceil(HOLO_MODELS:count() / SPAWNMENU_W)
        holoScaleUnits( MENU_BASE, vec(0,SPAWNMENU_W,SPAWNMENU_H)*SPAWNMENU_SCL )
        holoPos(MENU_BASE,entity():pos()+vec(0,0,(SPAWNMENU_H/2)*SPAWNMENU_SCL))
        
        MENU_ENT = holoEntity(MENU_BASE)
        
        DeleterCenter = vec(SPAWNMENU_SCL*0.6,(SPAWNMENU_W+0.2+1.5)*SPAWNMENU_SCL*0.5,SPAWNMENU_H*SPAWNMENU_SCL*0.5)
        
        SHREDDER_BASE = holoAlloc()
        holoPos(SHREDDER_BASE,entity():toWorld( DeleterCenter ))
        holoScaleUnits(SHREDDER_BASE,vec(1.5,1.5,0.75)*SPAWNMENU_SCL)
        holoModel(SHREDDER_BASE,"hq_stube_thin")
        holoMaterial(SHREDDER_BASE,"pac/default")
        holoColor(SHREDDER_BASE,vec(40))
        
        SHREDDER_BOTTOM = holoAlloc()
        holoPos(SHREDDER_BOTTOM,entity():toWorld( DeleterCenter + vec(-0.35,0,0)*SPAWNMENU_SCL ))
        holoAng(SHREDDER_BOTTOM,entity():toWorld(ang(0,0,90)))
        holoScaleUnits(SHREDDER_BOTTOM,vec(0.6,0.6,1.55)*SPAWNMENU_SCL)
        holoModel(SHREDDER_BOTTOM,"hexagon")
        holoMaterial(SHREDDER_BOTTOM,"pac/default")
        holoColor(SHREDDER_BOTTOM,vec(60))
        
        SHREDDER_TOP = holoAlloc()
        holoPos(SHREDDER_TOP,entity():toWorld( DeleterCenter + vec(0.35,0,0)*SPAWNMENU_SCL ))
        holoAng(SHREDDER_TOP,entity():toWorld(ang(0,0,90)))
        holoScaleUnits(SHREDDER_TOP,vec(0.6,0.6,1.55)*SPAWNMENU_SCL)
        holoModel(SHREDDER_TOP,"hexagon")
        holoMaterial(SHREDDER_TOP,"pac/default")
        holoColor(SHREDDER_TOP,vec(60))
        
        holoParent(SHREDDER_TOP,SHREDDER_BASE)
        holoParent(SHREDDER_BOTTOM,SHREDDER_BASE)
        holoParent(SHREDDER_BASE,MENU_BASE)
        
        holoAng(SHREDDER_BASE,MENU_ENT:toWorld(ang(90,0,0)))       
        SHREDDER = holoEntity(SHREDDER_BASE)
        
        BUCKET_BASE = holoAlloc()
        BucketCenter = vec(0.5,(SPAWNMENU_W+0.6+1.5)*-0.5,0.9)*SPAWNMENU_SCL
        holoPos(BUCKET_BASE,entity():toWorld(BucketCenter))
        holoModel(BUCKET_BASE,"hq_tube_thin")
        holoScaleUnits(BUCKET_BASE,vec(1.8,1.8,1.8)*SPAWNMENU_SCL)
        holoMaterial(BUCKET_BASE,"pac/default")
        BUCKET_ENT = holoEntity(BUCKET_BASE)
        
        BUCKET_PAINT = holoAlloc()
        holoParent(BUCKET_PAINT,BUCKET_BASE)
        holoPos(BUCKET_PAINT,entity():toWorld(BucketCenter-vec(0,0,0.1)*SPAWNMENU_SCL))
        holoModel(BUCKET_PAINT,"hq_cylinder")
        holoScaleUnits(BUCKET_PAINT,vec(1.7,1.7,1.6)*SPAWNMENU_SCL)
        holoMaterial(BUCKET_PAINT,"pac/default")
        holoParent(BUCKET_BASE,MENU_BASE)
        BUCKET_PAINT_ENT = holoEntity(BUCKET_PAINT)
        
        SidelenSolverPt = vec2(cos(BUCKET_ANGLE/(BUCKET_SATS-1)),sin(BUCKET_ANGLE/(BUCKET_SATS-1)))
        BUCKET_LEN = SidelenSolverPt[2] * (1/SidelenSolverPt[1]) * SPAWNMENU_SCL
        
        BUCKET_POINTER = holoAlloc()
        holoModel(BUCKET_POINTER,"hq_cone")
        holoScaleUnits(BUCKET_POINTER,vec(BUCKET_LEN*1.5))    
        holoParent(BUCKET_POINTER,BUCKET_BASE)
        
        BUCKET_POINTER_ENT = holoEntity(BUCKET_POINTER)
        
        X=Y=0
        
        SlidersCenter = vec(0,BucketCenter[2],SPAWNMENU_SCL*(SPAWNMENU_H-0.5))
        HelperHoloSize = SLIDER_BORDER*2/3
        SliderHelperOffset = vec(0,-0.9*SPAWNMENU_SCL - HelperHoloSize/2 - SPAWNMENU_SPACING,0)
        
        SliderHelper = holoAlloc( entity():toWorld(SlidersCenter + SliderHelperOffset + vec(0,-HelperHoloSize/8,HelperHoloSize/8)) )
        holoAlpha(SliderHelper,150)
        holoScaleUnits(SliderHelper, vec(HelperHoloSize))
        holoParent(SliderHelper,MENU_BASE)
        
        SliderHelper = holoAlloc( entity():toWorld(SlidersCenter + SliderHelperOffset + vec(0,HelperHoloSize/8,-HelperHoloSize/8)) )
        holoScaleUnits(SliderHelper, vec(HelperHoloSize))
        holoParent(SliderHelper,MENU_BASE)
        
        generateSlider("pos", SlidersCenter, POS_SNAP_DIVISORS)
        
        SlidersCenter = vec(0,BucketCenter[2],SPAWNMENU_SCL*(SPAWNMENU_H-1))
        
        SliderHelper = holoAlloc( entity():toWorld(SlidersCenter + SliderHelperOffset) )
        holoAlpha(SliderHelper,150)
        holoScaleUnits(SliderHelper, vec(HelperHoloSize*1.2))
        holoParent(SliderHelper,MENU_BASE)
        
        SliderHelper = holoAlloc( entity():toWorld(SlidersCenter + SliderHelperOffset) )
        holoScaleUnits(SliderHelper, vec(HelperHoloSize*1.2))
        holoAng(SliderHelper,entity():toWorld(ang(0,0,45)))
        holoParent(SliderHelper,MENU_BASE)
        
        generateSlider("ang", SlidersCenter, ANG_SNAP_DIVISORS)
        
        SlidersCenter = vec(0,BucketCenter[2],SPAWNMENU_SCL*(SPAWNMENU_H-1.5))
        
        SliderHelper = holoAlloc( entity():toWorld(SlidersCenter + SliderHelperOffset) )
        holoAlpha(SliderHelper,150)
        holoScaleUnits(SliderHelper, vec(HelperHoloSize*1.33))
        holoParent(SliderHelper,MENU_BASE)
        
        SliderHelper = holoAlloc( entity():toWorld(SlidersCenter + SliderHelperOffset) )
        holoScaleUnits(SliderHelper, vec(HelperHoloSize*1.33,HelperHoloSize*0.9,HelperHoloSize*0.9))
        holoParent(SliderHelper,MENU_BASE)
        
        generateSlider("scl", SlidersCenter, SCL_SNAP_DIVISORS)

        OriginPos = SlidersCenter + vec(0.5*SPAWNMENU_SCL,0,-SPAWNMENU_H*SPAWNMENU_SCL*0.2)
        
        ORIGIN = holoAlloc( entity():toWorld(OriginPos) )
        ORIGIN_ENT = holoEntity(ORIGIN)
        
        holoScale(ORIGIN,vec(0.1))
        holoColor(ORIGIN,vec(50))
        
        for(I=1, 3){
            local Offset = vec()
            Offset[I] = 3
            local Temp_Holo = holoAlloc( entity():toWorld(OriginPos + Offset) )
            holoModel(Temp_Holo,"hq_cylinder")
            holoMaterial(Temp_Holo,"lights/white")
            holoScale(Temp_Holo,vec(0.02,0.02,0.5))
            holoAng(Temp_Holo,Offset:toAngle()+ang(90,0,0))
            holoColor(Temp_Holo,Offset*255)
            holoParent(Temp_Holo,ORIGIN)
        }
        holoAng(ORIGIN, entity():angles())

}


event tick(){
    
    # -------- Menu Element Spawning -------- #
    
        # template holos
        while( MENU_SPAWNED < HOLO_MODELS:count() & holoCanCreate() ){
            
            MENU_SPAWNED++
            local MDL = HOLO_MODELS[MENU_SPAWNED,string]
            local Background = holoAlloc()
            local Holo = holoAlloc()
            
            if( !MENU_DATA:exists(Y) ){
                MENU_DATA[Y,table] = table()
            }
            
            local Pos = MENU_ENT:toWorld( vec(0,X,Y)*SPAWNMENU_SCL - vec(0,SPAWNMENU_W-1,SPAWNMENU_H-1)*0.5*SPAWNMENU_SCL + vec(1,0,0) )
            
            holoModel(Holo,MDL)
        
            holoColor(Background,vec(40),150)
            holoColor(Holo,vec(60))
            holoMaterial(Holo,"pac/default")    
        
            holoScaleUnits(Background,vec(0,1,1)*(SPAWNMENU_SCL-SPAWNMENU_SPACING))        
            holoScaleUnits(Holo,DEFAULT_SCALE)        
        
            holoPos(Background,Pos)
            holoPos(Holo,Pos+MENU_ENT:toWorldAxis(vec(SPAWNMENU_SCL*0.5,0,0)))
            
            holoAng(Holo,MENU_ENT:toWorld(ang(0,180,0) + HOLO_MODEL_OFFSETS[MDL,angle]))
            #holoAng(Background,MENU_ENT:angles())
            
            holoParent(Background,MENU_BASE)
            holoParent(Holo,MENU_BASE)
            
            if(MENU_SPAWNED==1){
                SELECT_BASE = Background
            }
            
            local HoloTable = table(
                "trueid" = Holo,
                "model" = MDL,
                "ent" = holoEntity(Holo),
                "scale" = DEFAULT_SCALE,
                "ismenu" = 1
            )
            
            MENU_DATA[Y,table][X,table] = HoloTable
            
            X=(X+1)%SPAWNMENU_W
            if(!X){Y++}   
        }
        
        # paint bucket stuff
        while( BUCKET_SPAWNED < BUCKET_SATS*BUCKET_BRIGHTS & holoCanCreate() ){
            BUCKET_SPAWNED++
         
            local Holo = holoAlloc()
            
            if(BUCKET_SPAWNED==1){ 
                X = Y = 0 
                holoPos(BUCKET_POINTER,BUCKET_ENT:toWorld(vec(SPAWNMENU_SCL+BUCKET_LEN,0,0)))
                holoAng(BUCKET_POINTER,BUCKET_ENT:toWorld(ang(-90,0,0)))
            }
            
            local Deg = (BUCKET_ANGLE*2)*X/(BUCKET_SATS-1)
            holoAng(Holo,BUCKET_ENT:toWorld(ang(0,Deg-90-BUCKET_ANGLE,-90)))
            holoPos(Holo,BUCKET_ENT:toWorld( vec(SPAWNMENU_SCL,0,SPAWNMENU_SCL*1.6*(Y/BUCKET_BRIGHTS-0.5+0.5/BUCKET_BRIGHTS)):rotate(ang(0,Deg-BUCKET_ANGLE,0)) ))
            holoScaleUnits(Holo,vec(BUCKET_LEN*2,1.6*SPAWNMENU_SCL/BUCKET_BRIGHTS,0.01))
            local HSV = vec(0, 1-X/(BUCKET_SATS-1), Y/(BUCKET_BRIGHTS-1))
            holoColor( Holo, hsv2rgb( HSV ) )
            holoMaterial( Holo, "lights/white" )
            holoParent( Holo, BUCKET_BASE )
            
            local HoloData = table(
                "trueid" = Holo,
                "hsv" = HSV,
                "hue" = (Y/BUCKET_BRIGHTS)*360 + (X/BUCKET_SATS)*360/BUCKET_BRIGHTS
            )
            
            BUCKET_DATA[(X+1),table][(Y+1),table] = HoloData
            X=(X+1)%BUCKET_SATS
            if(!X){Y++}   
        }
        
        # slider notches
        if( !SLIDER_NOTCHES_DONE ){
            foreach(_:string, T:table = SLIDER_DATA){
                local Values = T["values",array]
                while( holoCanCreate() & (T["notches",number] < Values:count()) ){
                    
                    T["notches",number] = T["notches",number] + 1
                    
                    local H = holoAlloc( T["slider_base_ent",entity]:toWorld(vec(0.5, T:sliderToWorld(Values[ T["notches",number], number]), 0)) )
                    holoScaleUnits(H, vec(0.01,SLIDER_SIZE/4,SLIDER_SIZE/4))
                    holoParent(H,T["slider_base",number])
                    
                }
                if( holoCanCreate() ){
                    SLIDER_NOTCHES_DONE = 1
                }
            }
        }
    # -------- End Menu Element Spawning -------- #
    
    
    
    ### global transients
    ##  not persisted, but defined every tick
        if(PLY:isPlayerInVR()){
            Hand_ang_ = PLY:getRightHandAngVR()
            Hand_pos_ = PLY:getRightHandPosVR()+Hand_ang_:forward()*5
        }
        else{
            Hand_pos_ = PLY:shootPos() + PLY:eye()*35
            Hand_ang_ = PLY:eyeAngles()
        }
        
        local GridPos = holoEntity(SELECT_BASE):toLocal(Hand_pos_)
              GridPos = round(GridPos/SPAWNMENU_SCL-vec(0.5,0,0))
        GridPos_x_ = GridPos[2]
        GridPos_y_ = GridPos[3]
        GridPos_z_ = GridPos[1]
    
    ##
    ### global transients
    
    switch( Action_Holding ){
        
        case 0, action_holdingNothing() break
        
        case HOLD_BucketPointer, action_holdingBucketPointer() break
        
        case HOLD_GrabbableHolo, action_holdingGrabbableHolo() break
        
        case HOLD_ScaleHandle, action_holdingScaleHandle() break
        
        case HOLD_Slider, action_holdingSlider() break
        
        case HOLD_Origin, action_holdingOrigin() break
    
    }
    
    if( changed(PLY:keyAttack1()) ){ # on m1 change
        
        if( PLY:keyAttack1() ){ # m1
            
            switch( Action_M1 ){
                
                case M1_BucketPointer,
                    Locals = toLocalPosAng(BUCKET_POINTER_ENT:pos(),BUCKET_POINTER_ENT:angles(),Hand_pos_,Hand_ang_)
                    Hand_Local_Pos = Locals[1,vector]
                    Hand_Local_Ang = Locals[2,angle]
                    
                    Action_Holding = HOLD_BucketPointer
                break
                
                case M1_ScaleHandle,
                    if( !Action_Holding ){ # this should never trigger if we're holding something
                        Target_M1["trueid",number]:highlight( vec(255,0,0), 150, 2) # change to red
                        Target_M1["ent",entity]:soundPlay("use"+Target_M1["trueid",number],0.5,"common/wpn_select.wav")
                        Hand_Local_Pos = Target_M1["ent",entity]:pos() - Hand_pos_
                        Handle_Axis = Target_M1["slider",vector]
                        Opposite_Handle = HANDLE_OPPOSITES[Handle_Axis+"",table]
                        Action_Holding = HOLD_ScaleHandle
                        
                        holoUnparent(HANDLE_CENTER)
                    }
                break
                
                case M1_Slider,
                    Target_M1["slider_ent",entity]:soundPlay("use_slider_"+Target_M1["name",string],0.5,"common/wpn_select.wav")
                    Action_Holding = HOLD_Slider
                break
                
                case M1_Duplicate,
                    local Tmp = holoCreateGrabbable( Target_Use )
                    Tmp["ent",entity]:soundPlay("duplicate"+Tmp["trueid",number],1,"ambient/water/drip2.wav")
                break
                
            }
            
        }
        else{ # un-m1
           
            switch( Action_Holding ){
                
                case HOLD_BucketPointer,
                    Action_Holding = 0
                    Bucket_State   = -1 # prevent bucket from getting stuck
                break
                
                case HOLD_ScaleHandle,
                    Action_Holding = 0
                break
                
                case HOLD_Slider, 
                    Action_Holding = 0
                break
                
            }
         
        }
        
    }
    
    
    if( changed(PLY:keyUse()) ){ # on use change 
            
        if(PLY:keyUse()){ # use
            local VurvCompilerBugFix = 1
            switch( Action_Use ){
                
                case USE_MenuHolo,
                
                    if( !Action_Holding & VurvCompilerBugFix ){
                        Target_Use = holoCreateGrabbable( Target_Use )
                        VurvCompilerBugFix = 0
                    }
                    # continue on to USE_GrabbableHolo case!
                    
                case USE_GrabbableHolo,
                
                    if( !Action_Holding ){ # this should never trigger if we're holding something
                        Locals = toLocalPosAng(Target_Use["ent",entity]:pos(),Target_Use["ent",entity]:angles(),Hand_pos_,Hand_ang_)
    
                        Hand_Local_Pos = Locals[1,vector]
                        Hand_Local_Ang = Locals[2,angle]
                        
                        holoPos(HANDLE_CENTER,Target_Use["ent",entity]:pos())
                        holoAng(HANDLE_CENTER,Target_Use["ent",entity]:angles())
                        holoParent(HANDLE_CENTER,Target_Use["trueid",number])
                        
                        0:highlight( vec(), 255, 2) # un-highlight any scale handles
                        
                        Action_Holding = HOLD_GrabbableHolo
                        Action_M1      = M1_Duplicate
                    }
                    
                break
                
                case USE_Origin,
                    Locals = toLocalPosAng(ORIGIN_ENT:pos(),ORIGIN_ENT:angles(),Hand_pos_,Hand_ang_)
                    Hand_Local_Pos = Locals[1,vector]
                    Hand_Local_Ang = Locals[2,angle]
                    
                    Action_Holding = HOLD_Origin
                break
            
            }
            
            switch( Action_Holding ){
                
                case HOLD_BucketPointer,
                    Bucket_State = 1
                break
                
            }
            
        }
        else{ # un-use
            
            switch( Action_Holding ){
                
                case HOLD_GrabbableHolo,
                    if( Target_Use["trueid",number] & GridPos_z_==0 & MENU_DATA:exists(GridPos_y_,GridPos_x_) ){ # they dropped it back in the menu, oops
                        holoFreeGrabbable(Target_Use)
                    }
                    elseif(Shredder_flash_){ # queue it for deletion
                        local SoundN = randint(2,3)
                        SHREDDER:soundPlay("trash"+SoundN,1,"player/footsteps/ice"+SoundN+".wav")
                        holoShredGrabbable(Target_Use)
                    }
                    Action_Holding = 0
                break
                
                case HOLD_BucketPointer,
                    Bucket_State = -1
                break
                
                case HOLD_Origin,
                    Action_Holding = 0
                break
            
            }
            
        }
    
    }

    if( changed( PLY:keyAttack2() ) ){ # on m2 change

        if( PLY:keyAttack2() ){ # m2
            do {
                
                # case: "use target is lockable"
                    if( !State_M2 & (Action_Use == USE_GrabbableHolo) ){
                        setHoloLock()
                        break
                    }
                # case: "should unlock"
                    elseif( State_M2 == M2_SelectLock ){
                        clearHoloLock()
                        break
                    }
                    
                # default:
                    break
            }
            while(1) # switch didn't fit here, but I also don't wanna make a function to use break...
        }
        else { # un-m2
            # nothing here yet
        }

    }
    
    # stuff that runs every tick goes below:
    
    # -------- Bucket runOnTick -------- #
        if( Bucket_State==1 | Bucket_Flip > 0 ){
            
            local Ignore = !changed( Bucket_State ) # fixes a frame-perfect input bug where one row becomes may become incorrectly colored
            local Divisions = 8 # must be a power of 2
            
            Bucket_Flip = clamp(Bucket_Flip + Ignore*Bucket_State*(1/Divisions),0,BUCKET_BRIGHTS)
            local BucketRow = floor(Bucket_Flip)
            
            Rot = frac(Bucket_Flip) * (Divisions) / (Divisions-1)
            #print(frac(Bucket_Flip))
            
            for(N=1,BUCKET_SATS){
                local Deg = (BUCKET_ANGLE*2)*(N-1)/(BUCKET_SATS-1)
                local Holo = BUCKET_DATA[N,table][(BucketRow+1),table]
                holoAng(Holo["trueid",number],BUCKET_ENT:toWorld(ang(0,Deg+90*(-1+Rot*2)-BUCKET_ANGLE,-90)))
            }
    
            if(Rot==1){
                if(Bucket_State==1){
                    for(N=1,BUCKET_SATS){
                        local Holo = BUCKET_DATA[N,table][(BucketRow+1),table]
                        holoColor(Holo["trueid",number],hsv2rgb(Holo["hue",number],1,1))
                    }
                }
                else{
                    for(N=1,BUCKET_SATS){
                        local Holo = BUCKET_DATA[N,table][(BucketRow+1),table]
                        holoColor(Holo["trueid",number],hsv2rgb(Holo["hsv",vector]:setX(HUE_CURRENT)))
                    } 
                }
            }
        }
    # -------- End Bucket runOnTick -------- #
    
    
    # -------- Shredder runOnTick -------- #
        if(Shredder_flash_==1 | (Shredder_Flasher%1 != 0) ){
            Shredder_Flasher = round( ((Shredder_Flasher+0.02)%1)*50 )*0.02
        }
    
        holoColor(SHREDDER_BASE,vec(40)+vec(115)*(sin(Shredder_Flasher*180)^2))
    
        for(I=Shredding_Holos:count(),1,-1){
            
            local HoloObj = Shredding_Holos[I,table]
            local ID = HoloObj["trueid",number]
            
            if(HoloObj["hp",number]>0.05){
                Shredder_spin_ = 1 # keep the shredder on if we're shredding
                HoloObj["hp",number] = HoloObj["hp",number] * 0.9
                holoScaleUnits(ID, HoloObj["deathscale",vector]*HoloObj["hp",number])
                holoPos(ID, mix(HoloObj["deathpos",vector], SHREDDER:pos()-SHREDDER:up()*5, HoloObj["hp",number]))
            }
            else{
                #holoUnparent(HANDLE_CENTER) -- probably not needed, will remove when I'm sure
                holoFreeGrabbable(HoloObj)
                Shredding_Holos:remove(I)
            }
            
        }
    
        if(changed(Shredder_spin_)){
            if(Shredder_spin_){
                SHREDDER:soundPlay("shredder",0,"vehicles/apc/apc_start_loop3.wav")
            }
            else{
                soundStop("shredder")
                SHREDDER:soundPlay("shredderstop",1,"vehicles/apc/apc_shutdown.wav")
            }
        }
    
        Shredder_Speed    = (Shredder_Speed*0.9+Shredder_spin_*0.1)
        Shredder_Rotation = Shredder_Rotation + Shredder_Speed*20
        holoAng(SHREDDER_TOP,SHREDDER:toWorld(ang(-Shredder_Rotation,0,90)))
        holoAng(SHREDDER_BOTTOM,SHREDDER:toWorld(ang(Shredder_Rotation,0,90)))
        
        local DeletColor = mix( vec(255),vec(60),Shredder_Speed )
        holoColor(SHREDDER_TOP,DeletColor)
        holoColor(SHREDDER_BOTTOM,DeletColor)
    # -------- End Shredder runOnTick -------- #
    
    
    # -------- Slider runOnTick -------- #
    
        foreach(_:string, T:table = SLIDER_DATA){
            
            local Value = T["anim_value",number]
            
            Value = Value*0.9 + T["value",number]*0.1 # interpolate
            T["anim_value",number] = Value # write back
            
            Value = (Value - T["min",number]) / T["range",number] # 0-1
            Value = (Value - 0.5)*2*T["maxpos",number] # local space
            
            holoPos(T["slider",number], T["slider_base_ent",entity]:toWorld( vec(SLIDER_HOVER_DISTANCE,Value,0) ))
        }
    
    # -------- End Slider runOnTick -------- #
    
}

# -------- Saving Stuff -------- #
event chat(Ply:entity, Text:string, _:number){

    if(Ply != PLY){ exit() }
    
    S = Text:explode(" ")
    
    if(S[1,string] == ".c"){
        Struct = S[2,string]
        if(HOLOSTRUCTURE_DATA:exists(Struct)){
            HOLOSTRUCTURE_DATA[Struct,table]["spawnChild",string] = "convertToGrabbable"
            holoAng( holoStructCreate(Struct,ORIGIN_ENT:pos()), ORIGIN_ENT:angles() )
        }
        else {
            owner():soundPlay("load",1,"buttons/button10.wav")
            print("structure not included")
        }
    }
    
    if(S[1,string] == ".g"){
        New_Holo_Group = S[2,string]
        print("group set to: \""+New_Holo_Group+"\"")
    }
    
    # If anyone really needs it, bother me with an issue and I'll make a UI for this command
    if(S[1,string] == ".m"){
        Bucket_Material = S[2,string]
        holoMaterial(BUCKET_PAINT, Bucket_Material)
        print("paint material set to: \""+Bucket_Material+"\"")
    }
    
    if(S[1,string] == ".f"){
        local Choice = table("x"=1,"y"=2,"z"=3)[S[2,string],number]
        if( Choice ){
            local Axis = vec()
            Axis[Choice] = 1
            Axis = ORIGIN_ENT:toWorldAxis(Axis)
            local Origin = ORIGIN_ENT:pos()
            for(I=1,Grab_Holos:count()){
                local Holo = Grab_Holos[I,table]["trueid",number]
                if(Holo){
                    local Ent = holoEntity(Holo)
                    local PosAng = Ent:getMirrored(Origin, Axis)
                    holoPos(Holo,PosAng["pos",vector])
                    holoAng(Holo,PosAng["ang",angle])
                }
            }
        }
        else {
            owner():soundPlay("save",1,"buttons/button10.wav")             
        }
    }
    
    if(S[1,string] == ".s"){
        if( S[2,string] != "" ){
            
            local ValidHolos = table()
        
            for(I=1,Grab_Holos:count()){
                local Holo = Grab_Holos[I,table]
                if(Holo["group",string] == New_Holo_Group){ # we've got a valid one!
                    ValidHolos:pushTable( Holo )
                }
            }
            
            local Models    = array()
            local Positions = array()
            local Angles    = array()
            local Scales    = array()
            local Colors    = array()
            local Materials = array()
            
            foreach(_:number, Holo:table = ValidHolos){
                local Mdl = Holo["model",string]
                Models:pushString( "\""+Mdl+"\"" )
                
                local Pos = round(ORIGIN_ENT:toLocal(Holo["ent",entity]:pos()), 5)
                Positions:pushString( "vec("+Pos[1]+","+Pos[2]+","+Pos[3]+")" )
                
                local Ang = round(ORIGIN_ENT:toLocal(Holo["ent",entity]:angles()), 3)
                Angles:pushString( "ang("+Ang[1]+","+Ang[2]+","+Ang[3]+")" )
                
                local Scl = round(Holo["scale",vector] / 12, 5)
                Scales:pushString( "vec("+Scl[1]+","+Scl[2]+","+Scl[3]+")" )
                
                local Col = round(Holo["ent",entity]:getColor())
                Colors:pushString( "vec("+Col[1]+","+Col[2]+","+Col[3]+")" )
                
                local Mat = Holo["ent",entity]:getMaterial()
                Materials:pushString( "\""+Mat+"\"" )
            }
            
            local Code = "@name holo structure: " + S[2,string] + "\n" +
                         "#include \"holostructurelib\"" + "\n\n" +
                         "# ~ #include this in your e2 to use with holostructurelib" + "\n" +
                         "# ~ exported by fast's vr hologram designer on " + getTimeStamp() + "\n\n" +
                         "if(first()){ registerStructure(\"" + S[2,string] + "\",table(" + "\n" +
                         "  \"models\" = array(" + Models:concat(",") + ")," + "\n" +
                         "  \"positions\" = array(" + Positions:concat(",") + ")," + "\n" +
                         "  \"angles\" = array(" + Angles:concat(",") + ")," + "\n" +
                         "  \"scales\" = array(" + Scales:concat(",") + ")," + "\n" +
                         "  \"colors\" = array(" + Colors:concat(",") + ")," + "\n" +
                         "  \"materials\" = array(" + Materials:concat(",") + ")" + "\n" +
                         "))}\n"
            
            fileWrite(">e2shared/vrmodels/"+S[2,string]+".txt",Code)
            print("saved")
            owner():soundPlay("save",1,"buttons/button9.wav")
            
        }
        else{
            owner():soundPlay("save",1,"buttons/button10.wav") 
        }
    }
    
}

